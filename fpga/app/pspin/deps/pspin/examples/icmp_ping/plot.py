#!/usr/bin/env python3

import csv
import argparse
import re
import numpy as np
import scipy.stats as st
import pandas as pd
import sys
from math import ceil
from itertools import chain
from os import listdir
from os.path import isfile, join

import matplotlib.pyplot as plt
import matplotlib.text as mtext
import seaborn as sns

parser = argparse.ArgumentParser(
    prog='plot.py',
    description='Plot data generated by the pingpong benchmark',
    epilog='Report bugs to Pengcheng Xu <pengxu@ethz.ch>.'
)

parser.add_argument('--data_root', help='root of the CSV files from the datatypes benchmark', default=None)
parser.add_argument('--query', action='store_true', help='query data interactively')

args = parser.parse_args()

def cycles_to_us(cycles):
    return 1e6 / pspin_freq * cycles

pspin_freq = 40e6 # 40 MHz
dat_pkl = 'data.pkl'

icmp_baseline_label = 'ICMP Host'
icmp_pspin_label = 'ICMP FPsPIN'
icmp_combined_label = 'ICMP Host+FPsPIN'

udp_baseline_label = 'UDP Host'
udp_pspin_label = 'UDP FPsPIN'
udp_combined_label = 'UDP Host+FPsPIN'

expect_count = 1000

def consume_trials(key, trials):
    # we do not distinguish host dma and notification here
    # since host is notified on every write
    def append_row(len, type, e2e, e2e_lo, e2e_hi, real_handler, host_dma, cycles):
        global data
        entry = pd.DataFrame.from_dict({
            'len': [len],
            'type': [type],
            'e2e': [e2e],
            'e2e_lo': [e2e_lo],
            'e2e_hi': [e2e_hi],
            'sender': [e2e - real_handler - host_dma - cycles],
            'real_handler': [real_handler],
            'host_dma': [host_dma],
            'cycles': [cycles],
        })
        data = pd.concat([data, entry], ignore_index=True)

    prot, trial = key.split(' ')

    for l in trials:
        real_handler, host_dma, all_cycles = 0, 0, 0

        if 'FPsPIN' in trial:
            do_host = 'true' if 'Host' in trial else 'false'
            txt_name = do_host

            with open(join(args.data_root, prot.lower(), f'{do_host}-{l}.csv'), 'r') as f:
                reader = csv.reader(f)
                assert next(reader) == ['handler', 'host_dma', 'cycles']
                icmp_handler, icmp_host_dma, cycles = [float(x) for x in next(reader)]

            real_handler = icmp_handler - cycles
            if do_host == 'true':
                real_handler -= icmp_host_dma + cycles
                host_dma = icmp_host_dma - cycles
                all_cycles = cycles * 5
            else:
                all_cycles = cycles * 3
        else:
            txt_name = 'baseline'

        with open(join(args.data_root, prot.lower(), f'{txt_name}-{l}-ping.txt'), 'r') as f:
            lines = filter(
                lambda l: l.find('time=') != -1 and l.find('timeout') == -1,
                f.readlines())
            if prot == 'ICMP':
                idx = 6
            elif prot == 'UDP': # dgping
                idx = 5
        values = [float(l.split(' ')[idx].split('=')[1]) * 1000 for l in lines]

        '''
        # plot the distributions
        fig, (ax1, ax2) = plt.subplots(2, figsize=(7, 2), sharex=True, layout='tight')
        sns.pointplot(x=values, errorbar='ci', estimator='median', capsize=.3, ax=ax1)
        sns.stripplot(x=values, jitter=.3, ax=ax2)
        fig.savefig(f'{prot}-{txt_name}-{l}.pdf')
        plt.close(fig)
        '''

        # 95% confidence interval
        median = np.median(values)
        bootstrap_ci = st.bootstrap((values,), np.median, confidence_level=0.95, method='percentile')
        ci_lo, ci_hi = bootstrap_ci.confidence_interval

        append_row(int(l), key, median, median - ci_lo, ci_hi - median,
                   cycles_to_us(real_handler),
                   cycles_to_us(host_dma),
                   cycles_to_us(all_cycles))

if args.data_root:
    trials = range(16, 1516, 100)
    data = pd.DataFrame(columns=[
        'len',
        'type',
        'e2e',
        'e2e_lo',
        'e2e_hi',
        'sender',
        'real_handler',
        'host_dma',
        'cycles',
    ])
    consume_trials(icmp_baseline_label, trials)
    consume_trials(icmp_combined_label, trials)
    consume_trials(icmp_pspin_label, trials)

    consume_trials(udp_baseline_label, trials)
    consume_trials(udp_combined_label, trials)
    consume_trials(udp_pspin_label, trials)

    data['len'] = data['len'].astype(int)
    data.to_pickle(dat_pkl)

# https://stackoverflow.com/a/71540238/5520728
class LegendTitle(object):
    def __init__(self, text_props=None):
        self.text_props = text_props or {}
        super(LegendTitle, self).__init__()

    def legend_artist(self, legend, orig_handle, fontsize, handlebox):
        x0, y0 = handlebox.xdescent, handlebox.ydescent
        title = mtext.Text(x0, y0, orig_handle, **self.text_props)
        handlebox.add_artist(title)
        return title

params = {
    'font.family': 'Helvetica Neue',
    'font.weight': 'light',
    'font.size': 9,
    'axes.titlesize': 'medium',
    'axes.titleweight': 'light',
    'figure.autolayout': True,
}
plt.rcParams.update(params)
figwidth=5.125
def figsize(aspect_ratio):
    return (figwidth, figwidth/aspect_ratio)

dp: pd.DataFrame = pd.read_pickle(dat_pkl)
if args.query:
    import code
    code.InteractiveConsole(locals=globals()).interact()
    sys.exit(0)

# E2E Latency
fig, ax = plt.subplots(figsize=figsize(5/3))

task_dict = {}
for lbl in [icmp_baseline_label, icmp_pspin_label, icmp_combined_label, udp_baseline_label, udp_pspin_label, udp_combined_label]:
    task, setup = lbl.split(' ')

    trial = dp[dp['type'] == lbl]
    trial.plot(x='len', y='e2e', yerr=(trial['e2e_lo'], trial['e2e_hi']), ax=ax, ecolor='black')

    task_dict.setdefault(task, {})[setup] = ax.lines[-1]

ax.grid(which='minor', alpha=0.2)
ax.grid(which='major', alpha=0.5)
ax.set_xlabel('Payload Length (B)')
ax.set_ylabel('E2E Latency (us)')
ax.get_legend().remove()

graphics, texts = [], []
for idx, (k, kv) in enumerate(task_dict.items()):
    graphics.append(k)
    texts.append('')
    for kk, vv in kv.items():
        graphics.append(vv)
        texts.append(kk)
    
    if idx != len(task_dict) - 1:
        graphics.append('')
        texts.append('')

ax.legend(graphics, texts, handler_map={str: LegendTitle({'weight': 'normal'})}, bbox_to_anchor=(1.03, .5), loc='center left')
fig.savefig('pingpong-lat.pdf')

indices = ['cycles', 'real_handler', 'host_dma', 'sender']
index_labels = ['Syscall', 'Handler', 'Host Proc.', 'Link+Sender']

# stackplot for components
# https://matplotlib.org/stable/gallery/subplots_axes_and_figures/gridspec_multicolumn.html
fig = plt.figure(figsize=figsize(6/5))
gs = fig.add_gridspec(3, 2, height_ratios=[1, 2, 2])
ax_labels = [[icmp_pspin_label, icmp_combined_label], [udp_pspin_label, udp_combined_label]]
axes = [[None, None], [None, None]]
did_labels = False
for x in range(2):
    for y in range(1, 3):
        lbl = ax_labels[y-1][x]
        if axes[0][0]:
            ax = fig.add_subplot(gs[y, x], sharex=axes[0][0], sharey=axes[0][0])
        else:
            ax = fig.add_subplot(gs[y, x])

        axes[y-1][x] = ax

        ax.set_yticks(range(0, 300, 100))
        ax.set_yticks(range(0, 300, 20), minor=True)

        ax.grid(which='minor', alpha=0.2)
        ax.grid(which='major', alpha=0.5)

        ax.set_title(lbl)
        ax.set_xlabel('Payload Length (B)')
        ax.set_ylabel('Latency (us)')
        ax.label_outer()
        
        trial = dp[dp['type'] == lbl]
        
        host_lbl = icmp_baseline_label if 'ICMP' in lbl else udp_baseline_label
        host_avg = dp[dp['type'] == host_lbl]['e2e'].median()

        axhline_kw = {'color': 'purple', 'linestyle': '--'}
        stackplot_kw = {'data': trial}
        if not did_labels:
            did_labels = True
            axhline_kw['label'] = 'Baseline'
            stackplot_kw['labels'] = index_labels

        stack = ax.stackplot('len', *indices, **stackplot_kw)
        ax.axhline(y=host_avg, **axhline_kw)

        index_colors = [s.get_facecolor() for s in stack]

        # plot error bars of e2e latencies
        ax.errorbar('len', 'e2e', (trial['e2e_lo'], trial['e2e_hi']), data=trial, fmt='none', label=None, ecolor='black')

color_dict = dict(zip(indices, index_colors))

timeline_pspin = [('sender', 2), ('cycles', .2), ('real_handler', 12), ('cycles', .2), ('sender', 2)]
timeline_combined = [('sender', 2), ('cycles', .2), ('real_handler', 2), ('cycles', .2), ('host_dma', 4), ('cycles', .2), ('real_handler', 2), ('cycles', .2), ('sender', 2)]

idx1, idx2 = 0, 0

segments = []
labels = []
while idx1 < len(timeline_pspin) or idx2 < len(timeline_combined):
    tp, vp = timeline_pspin[idx1]
    tc, vc = timeline_combined[idx2]
    if tp == tc:
        segments.append([vp, vc])
        labels.append(tp)
        idx1 += 1
        idx2 += 1
    else:
        # assuming that len(pspin) < len(combined)
        segments.append([0, vc])
        labels.append(tc)
        idx2 += 1

yticks = ['F', 'H+F']

ax = fig.add_subplot(gs[0, :])
left = np.zeros(2)
for s, l in zip(segments, labels):
    ax.barh(range(2), width=s, height=0.6, color=color_dict[l], left=left)
    left += np.array(s)

ax.set_yticks(range(2), yticks)
ax.tick_params('x', which='both', bottom=False, top=False, labelbottom=False)
ax.set_xlabel('Handler Execution Timeline')
ax.invert_yaxis()

fig.legend(bbox_to_anchor=(1, .5), loc='center right')
fig.tight_layout(rect=[0, 0, .75, 1])
fig.savefig('pingpong-breakdown.pdf')